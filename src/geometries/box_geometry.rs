use super::Geometry;

/// Rectangular cuboid shape.
pub struct BoxGeometry {
    /// The length of the sides parallel to the X axis.
    pub width: f32,
    /// The length of the sides parallel to the Y axis.
    pub height: f32,
    /// The length of the sides parallel to the Z axis.
    pub depth: f32,
    /// Number of segmented faces along the width.
    pub width_segments: u32,
    /// Number of segmented faces along the height.
    pub height_segments: u32,
    /// Number of segmented faces along the depth.
    pub depth_segments: u32,
}

impl Default for BoxGeometry {
    /// Returns the default box, which is the unit cube of length `1.0` and
    /// one segment along each side.
    fn default() -> Self {
        Self {
            width: 1.0,
            height: 1.0,
            depth: 1.0,
            width_segments: 1,
            height_segments: 1,
            depth_segments: 1,
        }
    }
}

impl BoxGeometry {
    /// Builds the vertices for the face with the given data specified in terms
    /// of UV coordinates, where the origin is the bottom left corner.
    ///
    /// * `face`: The face of the box to build for. `1` for +X, `2` for +Y, any
    ///   other positive integer for +Z, and their negates for the same face in
    ///   the opposite direction.
    /// * `u_length`: Length of the face in the U axis.
    /// * `y_length`: Length of the face in the V axis.
    /// * `w_length`: Length of the face in the third axis.
    /// * `u_segments`: Number of segments along the U axis.
    /// * `v_segments`: Number of segments along the V axis.
    ///
    /// ## Returns
    ///
    /// A tuple with the position buffer, normal buffer, and UV buffer in that
    /// order.
    fn build_face(
        face: i32,
        u_length: f32,
        v_length: f32,
        w_length: f32,
        u_segments: u32,
        v_segments: u32,
    ) -> (Vec<f32>, Vec<f32>, Vec<f32>) {
        // Example:
        // u_segments = 3
        // v_segments = 2
        //
        //   2 *--*--*--*
        //     |\ |\ |\ |
        // ^   | \| \| \|
        // | 1 *--*--*--*
        // |   |\ |\ |\ |
        // |   | \| \| \|
        // v 0 *--*--*--*
        //     0  1  2  3
        //     u--->
        //
        // Each asterisk represents a vertex. Insert vertex from left to right,
        // bottom to top.

        let num_vertices = (u_segments + 1) * (v_segments + 1);

        let mut position = Vec::with_capacity(num_vertices as usize);
        let mut normal = Vec::with_capacity(num_vertices as usize);
        let mut uv = Vec::with_capacity(num_vertices as usize);

        let hu = u_length / 2.0; // Half U length
        let hv = v_length / 2.0;
        let hw = w_length / 2.0;

        let s = face.signum() as f32;

        let usl = u_length / u_segments as f32; // U-segment length
        let vsl = v_length / v_segments as f32;

        for j in 0..=v_segments {
            for i in 0..=u_segments {
                let u_offset = usl * i as f32;
                let v_offset = vsl * j as f32;

                position.extend(match face.unsigned_abs() {
                    1 => [hw * s, -hv + v_offset, (hu - u_offset) * s],
                    2 => [-hu + u_offset, hw * s, (hv - v_offset) * s],
                    _ => [(-hu + u_offset) * s, -hv + v_offset, hw * s],
                });

                let mut norm_vector = [0.0f32; 3];

                norm_vector[face.unsigned_abs() as usize - 1] = 1.0 * face.signum() as f32;

                normal.extend(norm_vector);

                uv.extend([i as f32 / u_segments as f32, j as f32 / v_segments as f32]);
            }
        }

        (position, normal, uv)
    }

    /// Builds the indices for the face with the given data specified in terms
    /// of UV coordinates, where the origin is the bottom left corner.
    ///
    /// Similar to [`Self::build_face_vertices`] but for indices.
    ///
    /// * `u_segments`: Number of segments along the U axis.
    /// * `v_segments`: Number of segments along the V axis.
    /// * `base_vertex`: The constant to add to all indices generated by this
    ///   method. Generated indices start with `0`.
    fn build_face_indices(u_segments: u32, v_segments: u32, base_vertex: u32) -> Vec<u32> {
        // Example:
        // u_segments = 3
        // v_segments = 2
        //
        //   2 8--9-10-11
        //     |\ |\ |\ |
        // ^   | \| \| \|
        // | 1 4--5--6--7
        // |   |\ |\ |\ |
        // |   | \| \| \|
        // v 0 0--1--2--3
        //     0  1  2  3
        //     u--->
        //
        // If we visualize this as a matrix, then it becomes:
        //
        // | 0| 1| 2| 3|
        // | 4| 5| 6| 7|
        // | 8| 9|10|11|
        //
        // …and the indices will be: 0, 1, 4, 4, 1, 5, 1, 2, 5, 5, 2, 6,…
        //
        // The algorithm is roughly: for each matrix cell in row-major order,
        // excluding the last row and the last column:
        //
        // 1. Push the current element.
        // 2. Push the element on the right.
        // 3. Push the element below.
        // 4. Push the element from step 3.
        // 5. Push the element from step 2.
        // 6. Push the element to the right and below.

        // Number of segments * 2 (triangles) * 3 (vertices)
        let num_indices = u_segments * v_segments * 2 * 3;

        let mut indices = Vec::with_capacity(num_indices as usize);

        for i in 0..(u_segments + 1) * v_segments {
            // Skip the last column.
            if (i + 1) % (u_segments + 1) == 0 {
                continue;
            }

            indices.push(base_vertex + i);
            indices.push(base_vertex + i + 1);
            indices.push(base_vertex + i + u_segments + 1);
            indices.push(base_vertex + i + u_segments + 1);
            indices.push(base_vertex + i + 1);
            indices.push(base_vertex + i + u_segments + 2);
        }

        indices
    }
}

//    *--------*
//   /|       /|
//  *--------* |    +Y
//  | |      | |     |
//  | *------|-*     |---+X
//  |/       |/     /
//  *--------*    +Z
impl Geometry for BoxGeometry {
    fn vertices(&self) -> (Vec<f32>, Vec<f32>, Vec<f32>) {
        let num_vertices = 2 * ((self.width_segments + 1) * (self.depth_segments + 1))
            + 2 * ((self.width_segments + 1) * (self.height_segments + 1))
            + 2 * ((self.height_segments + 1) * (self.depth_segments + 1));

        let mut position = Vec::with_capacity(num_vertices as usize);
        let mut normal = Vec::with_capacity(num_vertices as usize);
        let mut uv = Vec::with_capacity(num_vertices as usize);

        // Build the +X face
        let pos_x_face = Self::build_face(
            1,
            self.depth,
            self.height,
            self.width,
            self.depth_segments,
            self.height_segments,
        );

        // Build the +Y face
        let pos_y_face = Self::build_face(
            2,
            self.width,
            self.depth,
            self.height,
            self.width_segments,
            self.depth_segments,
        );

        // Build the +Z face
        let pos_z_face = Self::build_face(
            3,
            self.width,
            self.height,
            self.depth,
            self.width_segments,
            self.height_segments,
        );

        // Build the -X face
        let neg_x_face = Self::build_face(
            -1,
            self.depth,
            self.height,
            self.width,
            self.depth_segments,
            self.height_segments,
        );

        // Build the -Y face
        let neg_y_face = Self::build_face(
            -2,
            self.width,
            self.depth,
            self.height,
            self.width_segments,
            self.depth_segments,
        );

        // Build the -Z face
        let neg_z_face = Self::build_face(
            -3,
            self.width,
            self.height,
            self.depth,
            self.width_segments,
            self.height_segments,
        );

        position.extend(pos_x_face.0);
        position.extend(pos_y_face.0);
        position.extend(pos_z_face.0);
        position.extend(neg_x_face.0);
        position.extend(neg_y_face.0);
        position.extend(neg_z_face.0);

        normal.extend(pos_x_face.1);
        normal.extend(pos_y_face.1);
        normal.extend(pos_z_face.1);
        normal.extend(neg_x_face.1);
        normal.extend(neg_y_face.1);
        normal.extend(neg_z_face.1);

        uv.extend(pos_x_face.2);
        uv.extend(pos_y_face.2);
        uv.extend(pos_z_face.2);
        uv.extend(neg_x_face.2);
        uv.extend(neg_y_face.2);
        uv.extend(neg_z_face.2);

        (position, normal, uv)
    }

    fn indices(&self) -> Option<Vec<u32>> {
        let x_face_index_count = (self.height_segments + 1) * (self.depth_segments + 1);
        let y_face_index_count = (self.width_segments + 1) * (self.depth_segments + 1);
        let z_face_index_count = (self.width_segments + 1) * (self.height_segments + 1);

        let mut indices = Vec::with_capacity(
            2 * (x_face_index_count + y_face_index_count + z_face_index_count) as usize,
        );

        // Build the +X face
        indices.extend(Self::build_face_indices(
            self.depth_segments,
            self.height_segments,
            0,
        ));

        // Build the +Y face
        indices.extend(Self::build_face_indices(
            self.width_segments,
            self.depth_segments,
            x_face_index_count,
        ));

        // Build the +Z face
        indices.extend(Self::build_face_indices(
            self.width_segments,
            self.height_segments,
            x_face_index_count + y_face_index_count,
        ));

        // Build the -X face
        indices.extend(Self::build_face_indices(
            self.depth_segments,
            self.height_segments,
            x_face_index_count + y_face_index_count + z_face_index_count,
        ));

        // Build the -Y face
        indices.extend(Self::build_face_indices(
            self.width_segments,
            self.depth_segments,
            2 * x_face_index_count + y_face_index_count + z_face_index_count,
        ));

        // Build the -Z face
        indices.extend(Self::build_face_indices(
            self.width_segments,
            self.height_segments,
            2 * x_face_index_count + 2 * y_face_index_count + z_face_index_count,
        ));

        Some(indices)
    }
}
